{"version":3,"file":"index.umd.min.js","sources":["../../src/number.ts","../../src/package.ts","../../src/string.ts","../../src/env.ts","../../src/function.ts","../../src/array.ts"],"sourcesContent":["/**\n * return true if given value is numeric.\n * @param {*} x - any value\n * @returns {boolean} - value is a number\n */\nexport const isNumber = (x: any): boolean => typeof x === 'number' && !Number.isNaN(x);\n\n/**\n * divide two numbers and returns fallback\n * for unexpected output\n * @param {number} dividend - dividend\n * @param {number} divisor - divisor\n * @param {*} [fallback=0] - fallback value when divisor is 0\n * @returns {number | any } if divisor isn't 0 dividend/divisor elsewhere fallback\n */\nexport const safeDivide = (dividend: number, divisor: number, fallback: any = 0): any =>\n  isNumber(dividend / divisor) ? dividend / divisor : fallback;\n\n/**\n * clamp a number between two values\n * @param {number} value - value to clamp\n * @param {[number, number]} [range=[0, 1]] - clamp range\n * @returns {number} clamped number\n */\nexport const clamp = (value: number, [min, max]: number[] = [0, 1]): number => Math.max(Math.min(value, max), min);\n\n/**\n * returns percentage value of a number from a maximum number\n * @param {number} value - current value\n * @param {number} max - max value\n * @returns {number} cuurent / max * 100 (return 0 on fallback)\n */\nexport const percent = (value: number, max: number): number => clamp(safeDivide(value, max)) * 100;\n\n/**\n * random int number between two value\n * @param {range} [range = { min = 0, max = MAX_SAFE_INTEGER }] - range of random numbers\n * @returns {number} random integer between min and max\n */\nexport const randomInt = ({ min = 0, max = Number.MAX_SAFE_INTEGER }: { min?: number; max?: number } = {}): number =>\n  Math.floor(Math.random() * (max - min)) + min;\n\n/**\n * parse number to integer in radix 10\n * @param {string} num number to parse\n * @returns {number} parsed number\n */\nexport const toInteger = (num: string): number => Number.parseInt(num, 10);\n\n/**\n * Checks if num is between min and max (and including borders).\n * @param {number} num number check\n * @param {[number, number]} [range] - range\n * @returns {boolean} number is between min and max\n */\nexport const isInRange = (num: number, [min, max]: [number, number]): boolean => num - min * num - max <= 0;\n","type PackageJson = Record<Dependencies, any>;\ntype Dependencies = 'peerDependencies' | 'devDependencies' | 'dependencies' | 'optionalDependencies';\n\nconst hasDepType = (packageJson: PackageJson) => (type: Dependencies) => (dep: string) =>\n  typeof packageJson[type] === 'object' && Reflect.has(packageJson[type], dep);\n\nexport const hasPeerDep = (packageJson: PackageJson) => hasDepType(packageJson)('peerDependencies');\nexport const hasDep = (packageJson: PackageJson) => hasDepType(packageJson)('dependencies');\nexport const hasDevDep = (packageJson: PackageJson) => hasDepType(packageJson)('devDependencies');\nexport const hasOptDep = (packageJson: PackageJson) => hasDepType(packageJson)('optionalDependencies');\n\nexport const hasAnyDep = (packageJson: PackageJson) => (dep: string) =>\n  [hasDep, hasDevDep, hasPeerDep, hasOptDep].some(isDepExist => isDepExist(packageJson)(dep));\n\nexport const ifAnyDep = (packageJson: PackageJson) => (dep: string, t?: Function, f?: Function) =>\n  hasAnyDep(packageJson)(dep) ? t?.() : f?.();\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Packages = (packageJson: PackageJson) => ({\n  hasOptDep: hasOptDep(packageJson),\n  hasPeerDep: hasPeerDep(packageJson),\n  hasDevDep: hasDevDep(packageJson),\n  hasDep: hasDep(packageJson),\n  hasAnyDep: hasAnyDep(packageJson),\n  ifAnyDep: ifAnyDep(packageJson),\n});\n","/**\n * converts crlf to lf\n * @param {string} str - value\n * @returns {string} value with lf line ending\n */\nexport const crlfToLF = (str: string): string => str.replace(/\\r\\n/g, '\\n');\n\n/**\n * uppercase first letter + lowercase rest\n * @param {string} str - word to become capitalize\n * @returns {string} Capitalzed value\n */\nexport const toCapitalCase = (str: string): string => str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();\n\n/**\n * convert kebab-case to camelCase\n * @param {string} str - kebab-case string\n * @returns {string} camelCase representation of string\n */\nexport const kebabToCamel = (str: string): string =>\n  str\n    .split('-')\n    .map((part, key) => (key === 0 ? part : toCapitalCase(part)))\n    .join('');\n\n/**\n * return initial chars of words\n * @param {string} name - value to get initials from\n * @param {string} [fallback='?'] - return value if opration failed\n * @returns {string} initials chars of a words || fallback\n * @example getInitials('frontend monsters'); //-> FM\n */\nexport const getInitials = (name: string, fallback = '?'): string =>\n  typeof name === 'string' && name.length > 0\n    ? name\n        .replace(/\\s+/g, ' ')\n        .split(' ')\n        .slice(0, 2)\n        .map(v => v?.[0].toUpperCase())\n        .join('')\n    : fallback;\n\n/**\n * check if value is null, undefined or empty string\n * @param {*} x - any value\n * @returns {boolean} is null | undefined | empty string\n */\nexport const isNullOrEmpty = (x: any): boolean => x == null || x === '';\n","const envs = {\n  prod: 'production',\n  dev: 'development',\n  test: 'test',\n};\n\n/**\n * give NODE_ENV value or given fallback value\n * @param {string} [fallback=\"development\"] fallback value if NODE_ENV is not present (default to \"development\")\n * @returns {string} NODE_ENV || fallback\n */\nexport const get = <T = string>(fallback: string | T = envs.dev): string | T => process.env.NODE_ENV || fallback;\n\n/**\n * strict check NODE_ENV with given value\n * @param {string} value env string to check\n * @returns {boolean} is given env strict equal to NODE_ENV\n */\nexport const is = (value: string): boolean => process.env.NODE_ENV === value;\n\n/**\n * check NODE_ENV starts with given value (case insensitive)\n * @param {string} value env string to check\n * @returns {boolean} is given env starts with equal to NODE_ENV\n */\nexport function match(value: string): boolean {\n  const env = get(null)?.toLocaleLowerCase();\n  return env?.startsWith(value.toLowerCase()) ?? false;\n}\n\n/**\n * check env matchs 'development'\n * @returns {boolean} true if env matches \"development\"\n */\nexport const matchDev = (): boolean => match(envs.dev);\n\n/**\n * check env matchs 'production'\n * @returns {boolean} true if env matches \"production\"\n */\nexport const matchProd = (): boolean => match(envs.prod);\n\n/**\n * check env matchs 'test'\n * @returns {boolean} true if env matches \"test\"\n */\nexport const matchTest = (): boolean => match(envs.test);\n\n// shortcuts\nexport const isDev = matchDev();\nexport const isProd = matchProd();\nexport const isTest = matchTest();\n","/**\n * noop ¯\\_(ツ)_/¯\n * @returns {void}\n */\nexport const noop = (): void => undefined;\n\n/**\n * call ginen functions with an args\n * @param {function[]} fns function to call\n * @returns {function} function that takes arguments\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const callAll = (...fns: Function[]) => (...args: any) =>\n  fns.forEach(fn => typeof fn === 'function' && fn(...args));\n","/**\n * wrap value with array if value is not an array itself.\n * @param {*} x - any value\n * @returns {any[]} - [value]\n */\nexport const forceArray = (x: any): any[] => [].concat(x);\n\n/**\n * create array of length n with from offset\n * @param {number} len - total number count\n * @param {number} [offset=0] - first number\n * @param {number} [step=1] - step\n * @returns {number[]} - range\n */\nexport const range = (len: number, offset = 0, step = 1): number[] =>\n  [...Array(len).keys()].map(i => i * step + offset);\n\n/**\n * returns array representation of a value\n * @param {any} value - any value\n * @returns {any []} - array representation of value\n */\nexport const toArray = (value: any): any[] => {\n  if (value == null) return [];\n  if (Array.isArray(value)) return value;\n  if (typeof value === 'string') return [value];\n  if (typeof value[Symbol.iterator] === 'function') return [...value];\n  return [value];\n};\n"],"names":["isNumber","x","Number","isNaN","safeDivide","dividend","divisor","fallback","clamp","value","_a","_b","__read","min","max","Math","hasDepType","packageJson","type","dep","Reflect","has","hasAnyDep","hasDep","hasDevDep","hasPeerDep","hasOptDep","some","isDepExist","ifAnyDep","t","f","toCapitalCase","str","charAt","toUpperCase","substring","toLowerCase","get","envs","process","env","NODE_ENV","match","toLocaleLowerCase","startsWith","matchDev","matchProd","matchTest","isDev","isProd","isTest","_i","fns","args","forEach","fn","replace","concat","name","length","split","slice","map","v","join","num","part","key","_c","_d","MAX_SAFE_INTEGER","floor","random","len","offset","step","__spread","Array","keys","i","isArray","Symbol","iterator","parseInt"],"mappings":"kMAKwB,SAAXA,EAAYC,GAAoB,MAAa,iBAANA,IAAmBC,OAAOC,MAAMF,GAU1D,SAAbG,EAAcC,EAAkBC,EAAiBC,GAC5D,oBAD4DA,KAC5DP,EAASK,EAAWC,GAAWD,EAAWC,EAAUC,EAQjC,SAARC,EAASC,EAAeC,OAAAC,EAAAC,aAAuB,CAAC,EAAG,QAA1BC,OAAKC,OAAoC,OAAAC,KAAKD,IAAIC,KAAKF,IAAIJ,EAAOK,GAAMD,GCrB3F,SAAbG,EAAcC,GAA6B,OAAA,SAACC,GAAuB,OAAA,SAACC,GACxE,MAA6B,iBAAtBF,EAAYC,IAAsBE,QAAQC,IAAIJ,EAAYC,GAAOC,KAOjD,SAAZG,EAAaL,GAA6B,OAAA,SAACE,GACtD,MAAA,CAACI,EAAQC,EAAWC,EAAYC,GAAWC,KAAK,SAAAC,GAAc,OAAAA,EAAWX,EAAXW,CAAwBT,MAEhE,SAAXU,EAAYZ,GAA6B,OAAA,SAACE,EAAaW,EAAcC,GAChF,OAAAT,EAAUL,EAAVK,CAAuBH,GAAOW,MAAAA,SAAAA,IAAQC,MAAAA,SAAAA,KCHX,SAAhBC,EAAiBC,GAAwB,OAAAA,EAAIC,OAAO,GAAGC,cAAgBF,EAAIG,UAAU,GAAGC,cCDlF,SAANC,EAAmB/B,GAAgD,oBAAhDA,EAAuBgC,GAAyBC,QAAQC,IAAIC,UAAYnC,ugCFL3FkB,EAAa,SAACR,GAA6B,OAAAD,EAAWC,EAAXD,CAAwB,qBACnEO,EAAS,SAACN,GAA6B,OAAAD,EAAWC,EAAXD,CAAwB,iBAC/DQ,EAAY,SAACP,GAA6B,OAAAD,EAAWC,EAAXD,CAAwB,oBAClEU,EAAY,SAACT,GAA6B,OAAAD,EAAWC,EAAXD,CAAwB,yBETzEuB,EACE,aADFA,EAEC,cAFDA,EAGE,gBAsBQI,EAAMlC,WACdgC,YAAMH,EAAI,4BAAOM,oBACvB,iBAAOH,MAAAA,SAAAA,EAAKI,WAAWpC,EAAM4B,+BAOP,SAAXS,IAA0B,OAAAH,EAAMJ,GAMpB,SAAZQ,IAA2B,OAAAJ,EAAMJ,GAMrB,SAAZS,IAA2B,OAAAL,EAAMJ,GAZvC,IAeMU,EAAQH,IACRI,EAASH,IACTI,EAASH,6CAjCJ,SAACvC,GAA2B,OAAA+B,QAAQC,IAAIC,WAAajC,qFFA/C,SAACQ,GAA6B,OACpDS,UAAWA,EAAUT,GACrBQ,WAAYA,EAAWR,GACvBO,UAAWA,EAAUP,GACrBM,OAAQA,EAAON,GACfK,UAAWA,EAAUL,GACrBY,SAAUA,EAASZ,eGZE,eAAC,aAAAmC,mBAAAA,IAAAC,kBAAuB,OAAA,eAAC,aAAAD,mBAAAA,IAAAE,kBAC9C,OAAAD,EAAIE,QAAQ,SAAAC,GAAM,MAAc,mBAAPA,GAAqBA,iBAAMF,6BFR9B,SAACrB,GAAwB,OAAAA,EAAIwB,QAAQ,QAAS,4BGA5C,SAACxD,GAAkB,MAAA,GAAGyD,OAAOzD,kBH2B5B,SAAC0D,EAAcpD,GACxC,oBADwCA,OACxB,iBAAToD,GAAmC,EAAdA,EAAKC,OAC7BD,EACGF,QAAQ,OAAQ,KAChBI,MAAM,KACNC,MAAM,EAAG,GACTC,IAAI,SAAAC,UAAKA,MAAAA,SAAAA,EAAI,GAAG7B,gBAChB8B,KAAK,IACR1D,gGFemB,SAAC2D,EAAaxD,OAAAC,EAAAC,OAA0C,OAAAsD,OAAYA,QAAa,mBER7E,SAACjE,GAAoB,OAAK,MAALA,GAAmB,KAANA,+BA5BnC,SAACgC,GAC3B,OAAAA,EACG4B,MAAM,KACNE,IAAI,SAACI,EAAMC,GAAQ,OAAS,IAARA,EAAYD,EAAOnC,EAAcmC,KACrDF,KAAK,YEnBU,uBJ4BG,SAACxD,EAAeK,GAAwB,OAAgC,IAAhCN,EAAMJ,EAAWK,EAAOK,iBAO9D,SAACJ,OAAAC,aAA6E,KAA3E0D,QAAAxD,aAAM,IAAGyD,QAAAxD,aAAMZ,OAAOqE,mBAChD,OAAAxD,KAAKyD,MAAMzD,KAAK0D,UAAY3D,EAAMD,IAAQA,WK1BvB,SAAC6D,EAAaC,EAAYC,GAC7C,oBADiCD,kBAAYC,KAC7CC,EAAIC,MAAMJ,GAAKK,QAAQhB,IAAI,SAAAiB,GAAK,OAAAA,EAAIJ,EAAOD,8BAOtB,SAAClE,GACtB,OAAa,MAATA,EAAsB,GACtBqE,MAAMG,QAAQxE,GAAeA,EACZ,iBAAVA,GAC2B,mBAA3BA,EAAMyE,OAAOC,YAAqC1E,GADvB,CAACA,kCLsBhB,SAACyD,GAAwB,OAAAhE,OAAOkF,SAASlB,EAAK"}