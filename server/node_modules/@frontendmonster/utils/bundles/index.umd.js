(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.utils = {}));
}(this, (function (exports) { 'use strict';

    var __read = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (undefined && undefined.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    /**
     * wrap value with array if value is not an array itself.
     * @param {*} x - any value
     * @returns {any[]} - [value]
     */
    var forceArray = function (x) { return [].concat(x); };
    /**
     * create array of length n with from offset
     * @param {number} len - total number count
     * @param {number} [offset=0] - first number
     * @param {number} [step=1] - step
     * @returns {number[]} - range
     */
    var range = function (len, offset, step) {
        if (offset === void 0) { offset = 0; }
        if (step === void 0) { step = 1; }
        return __spread(Array(len).keys()).map(function (i) { return i * step + offset; });
    };
    /**
     * returns array representation of a value
     * @param {any} value - any value
     * @returns {any []} - array representation of value
     */
    var toArray = function (value) {
        if (value == null)
            return [];
        if (Array.isArray(value))
            return value;
        if (typeof value === 'string')
            return [value];
        if (typeof value[Symbol.iterator] === 'function')
            return __spread(value);
        return [value];
    };

    var __read$1 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread$1 = (undefined && undefined.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$1(arguments[i]));
        return ar;
    };
    /**
     * noop ¯\_(ツ)_/¯
     * @returns {void}
     */
    var noop = function () { return undefined; };
    /**
     * call ginen functions with an args
     * @param {function[]} fns function to call
     * @returns {function} function that takes arguments
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    var callAll = function () {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return fns.forEach(function (fn) { return typeof fn === 'function' && fn.apply(void 0, __spread$1(args)); });
        };
    };

    var __read$2 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    /**
     * return true if given value is numeric.
     * @param {*} x - any value
     * @returns {boolean} - value is a number
     */
    var isNumber = function (x) { return typeof x === 'number' && !Number.isNaN(x); };
    /**
     * divide two numbers and returns fallback
     * for unexpected output
     * @param {number} dividend - dividend
     * @param {number} divisor - divisor
     * @param {*} [fallback=0] - fallback value when divisor is 0
     * @returns {number | any } if divisor isn't 0 dividend/divisor elsewhere fallback
     */
    var safeDivide = function (dividend, divisor, fallback) {
        if (fallback === void 0) { fallback = 0; }
        return isNumber(dividend / divisor) ? dividend / divisor : fallback;
    };
    /**
     * clamp a number between two values
     * @param {number} value - value to clamp
     * @param {[number, number]} [range=[0, 1]] - clamp range
     * @returns {number} clamped number
     */
    var clamp = function (value, _a) {
        var _b = __read$2(_a === void 0 ? [0, 1] : _a, 2), min = _b[0], max = _b[1];
        return Math.max(Math.min(value, max), min);
    };
    /**
     * returns percentage value of a number from a maximum number
     * @param {number} value - current value
     * @param {number} max - max value
     * @returns {number} cuurent / max * 100 (return 0 on fallback)
     */
    var percent = function (value, max) { return clamp(safeDivide(value, max)) * 100; };
    /**
     * random int number between two value
     * @param {range} [range = { min = 0, max = MAX_SAFE_INTEGER }] - range of random numbers
     * @returns {number} random integer between min and max
     */
    var randomInt = function (_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.min, min = _c === void 0 ? 0 : _c, _d = _b.max, max = _d === void 0 ? Number.MAX_SAFE_INTEGER : _d;
        return Math.floor(Math.random() * (max - min)) + min;
    };
    /**
     * parse number to integer in radix 10
     * @param {string} num number to parse
     * @returns {number} parsed number
     */
    var toInteger = function (num) { return Number.parseInt(num, 10); };
    /**
     * Checks if num is between min and max (and including borders).
     * @param {number} num number check
     * @param {[number, number]} [range] - range
     * @returns {boolean} number is between min and max
     */
    var isInRange = function (num, _a) {
        var _b = __read$2(_a, 2), min = _b[0], max = _b[1];
        return num - min * num - max <= 0;
    };

    var hasDepType = function (packageJson) { return function (type) { return function (dep) {
        return typeof packageJson[type] === 'object' && Reflect.has(packageJson[type], dep);
    }; }; };
    var hasPeerDep = function (packageJson) { return hasDepType(packageJson)('peerDependencies'); };
    var hasDep = function (packageJson) { return hasDepType(packageJson)('dependencies'); };
    var hasDevDep = function (packageJson) { return hasDepType(packageJson)('devDependencies'); };
    var hasOptDep = function (packageJson) { return hasDepType(packageJson)('optionalDependencies'); };
    var hasAnyDep = function (packageJson) { return function (dep) {
        return [hasDep, hasDevDep, hasPeerDep, hasOptDep].some(function (isDepExist) { return isDepExist(packageJson)(dep); });
    }; };
    var ifAnyDep = function (packageJson) { return function (dep, t, f) {
        return hasAnyDep(packageJson)(dep) ? t === null || t === void 0 ? void 0 : t() : f === null || f === void 0 ? void 0 : f();
    }; };
    // eslint-disable-next-line @typescript-eslint/naming-convention
    var Packages = function (packageJson) { return ({
        hasOptDep: hasOptDep(packageJson),
        hasPeerDep: hasPeerDep(packageJson),
        hasDevDep: hasDevDep(packageJson),
        hasDep: hasDep(packageJson),
        hasAnyDep: hasAnyDep(packageJson),
        ifAnyDep: ifAnyDep(packageJson),
    }); };

    /**
     * converts crlf to lf
     * @param {string} str - value
     * @returns {string} value with lf line ending
     */
    var crlfToLF = function (str) { return str.replace(/\r\n/g, '\n'); };
    /**
     * uppercase first letter + lowercase rest
     * @param {string} str - word to become capitalize
     * @returns {string} Capitalzed value
     */
    var toCapitalCase = function (str) { return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase(); };
    /**
     * convert kebab-case to camelCase
     * @param {string} str - kebab-case string
     * @returns {string} camelCase representation of string
     */
    var kebabToCamel = function (str) {
        return str
            .split('-')
            .map(function (part, key) { return (key === 0 ? part : toCapitalCase(part)); })
            .join('');
    };
    /**
     * return initial chars of words
     * @param {string} name - value to get initials from
     * @param {string} [fallback='?'] - return value if opration failed
     * @returns {string} initials chars of a words || fallback
     * @example getInitials('frontend monsters'); //-> FM
     */
    var getInitials = function (name, fallback) {
        if (fallback === void 0) { fallback = '?'; }
        return typeof name === 'string' && name.length > 0
            ? name
                .replace(/\s+/g, ' ')
                .split(' ')
                .slice(0, 2)
                .map(function (v) { return v === null || v === void 0 ? void 0 : v[0].toUpperCase(); })
                .join('')
            : fallback;
    };
    /**
     * check if value is null, undefined or empty string
     * @param {*} x - any value
     * @returns {boolean} is null | undefined | empty string
     */
    var isNullOrEmpty = function (x) { return x == null || x === ''; };

    var envs = {
        prod: 'production',
        dev: 'development',
        test: 'test',
    };
    /**
     * give NODE_ENV value or given fallback value
     * @param {string} [fallback="development"] fallback value if NODE_ENV is not present (default to "development")
     * @returns {string} NODE_ENV || fallback
     */
    var get = function (fallback) {
        if (fallback === void 0) { fallback = envs.dev; }
        return process.env.NODE_ENV || fallback;
    };
    /**
     * strict check NODE_ENV with given value
     * @param {string} value env string to check
     * @returns {boolean} is given env strict equal to NODE_ENV
     */
    var is = function (value) { return process.env.NODE_ENV === value; };
    /**
     * check NODE_ENV starts with given value (case insensitive)
     * @param {string} value env string to check
     * @returns {boolean} is given env starts with equal to NODE_ENV
     */
    function match(value) {
        var _a, _b;
        var env = (_a = get(null)) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase();
        return (_b = env === null || env === void 0 ? void 0 : env.startsWith(value.toLowerCase())) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * check env matchs 'development'
     * @returns {boolean} true if env matches "development"
     */
    var matchDev = function () { return match(envs.dev); };
    /**
     * check env matchs 'production'
     * @returns {boolean} true if env matches "production"
     */
    var matchProd = function () { return match(envs.prod); };
    /**
     * check env matchs 'test'
     * @returns {boolean} true if env matches "test"
     */
    var matchTest = function () { return match(envs.test); };
    // shortcuts
    var isDev = matchDev();
    var isProd = matchProd();
    var isTest = matchTest();

    var env = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get: get,
        is: is,
        match: match,
        matchDev: matchDev,
        matchProd: matchProd,
        matchTest: matchTest,
        isDev: isDev,
        isProd: isProd,
        isTest: isTest
    });

    exports.Packages = Packages;
    exports.callAll = callAll;
    exports.clamp = clamp;
    exports.crlfToLF = crlfToLF;
    exports.env = env;
    exports.forceArray = forceArray;
    exports.getInitials = getInitials;
    exports.hasAnyDep = hasAnyDep;
    exports.hasDep = hasDep;
    exports.hasDevDep = hasDevDep;
    exports.hasOptDep = hasOptDep;
    exports.hasPeerDep = hasPeerDep;
    exports.ifAnyDep = ifAnyDep;
    exports.isInRange = isInRange;
    exports.isNullOrEmpty = isNullOrEmpty;
    exports.isNumber = isNumber;
    exports.kebabToCamel = kebabToCamel;
    exports.noop = noop;
    exports.percent = percent;
    exports.randomInt = randomInt;
    exports.range = range;
    exports.safeDivide = safeDivide;
    exports.toArray = toArray;
    exports.toCapitalCase = toCapitalCase;
    exports.toInteger = toInteger;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
